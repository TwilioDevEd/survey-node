.step(data-title='The Voice Interview Loop', data-file='routes/voice.js', data-highlight='')
  :markdown
    ## The Voice Interview Loop

    It is helpful to visualize your interaction with a user during a survey as a loop. The chart below traces the flow of a user's phone call to your Twilio number to participate in the survey (click it to make it bigger):

    ![Survey Flow Chart](//s3.amazonaws.com/howtodocs/flowchart.png)

    The user can enter input for your survey over the phone using either their phone's keypad or by speaking. After each interaction, Twilio will make an HTTP request to your web application with either the string of keys the user pressed or a URL to a recording of their voice input.

    It's up to our application to process and store the user's input, maintain the current state of the conversation, and respond back to the user. Let's dive into this flow to see how it actually works.

.step(data-title='Responding to a Phone Call', data-file='routes/voice.js', data-highlight='')
  :markdown
    ## Responding to a Phone Call

    ![Survey Flow Chart](//s3.amazonaws.com/howtodocs/flowchart2.png)

    To initiate the interview process, we need to configure one of our [Twilio numbers][numbers] to send our web application an HTTP request when we get an incoming call or text (remember, our app accepts text messages as well, even though we're focusing on the voice side).

    [Click on one of your numbers][numbers] and configure Voice and Message URLs that point to your server. In our code, the routes were `/voice` and `/message`, respectively.

    ![Configuring a Twilio Number](//s3.amazonaws.com/howtodocs/number-config.png)

    [numbers]: /user/account/phone-numbers/incoming

.step(data-title='Responding to a Phone Call', data-file='routes/voice.js', data-highlight='5-9')
  :markdown
    ## Responding to a Phone Call

    ![Survey Flow Chart](//s3.amazonaws.com/howtodocs/flowchart3.png)

    The `voice` route maps to this Express handler function, which takes an HTTP request and HTTP response as arguments. On the request, we can access the phone number of the person calling in the `From` POST parameter - we can use this to uniquely identify a person taking the survey. 

    We can also access the `RecordingUrl`, which contains any voice input from the user. If that's not present, `Digits` may also be present, which contains the string of keys entered by the user on their keypad. If this is the user's first call to our system or they failed to enter any input to the previous question, these values might be blank Strings. 

    We also create a `TwimlResponse` object that we will use to build up a string of XML we can ultimately render as a response to Twilio's request. It's not doing anything fancy - it just provides a JavaScript object that we can use to progressively assemble a valid TwiML string as our program executes.

    [numbers]: /user/account/phone-numbers/incoming

.step(data-title='Asking a Question', data-file='routes/voice.js', data-highlight='11-48')
  :markdown
    ## Asking a Question

    ![Survey Flow Chart](//s3.amazonaws.com/howtodocs/flowchart4.png)

    If the user did not enter any input, it's the first question, or there's still another question after the current one, we will build a TwiML response that will ask the next question.

    We define a few inner functions here to help us build our response. `respond` ends our TwiML response and sends XML content back to Twilio. `say` is a shorthand for appending a string of text that will be read back to the user with Twilio TTS (text-to-speech) engine.

.step(data-title='Asking a Question', data-file='routes/voice.js', data-highlight='50-75')
  :markdown
    ## Asking a Question

    ![Survey Flow Chart](//s3.amazonaws.com/howtodocs/flowchart4.png)

    In our TwiML response, we need to include either a `Gather` tag or a `Record` tag to collect input from the user. Which tag we use depends on the question type in the survey.

    In the `Record` use case, we also provide a transcription callback URL. Unlike `Gather` and `Record`, the transcription callback happens outside the loop of the call, sometime in the very near future (several seconds rather than minutes). So while you can't count on having the transcript results during the flow of the call, you can add the transcript to your database record for the response to help enrich that data a bit.

    Another caveat here is that Twilio's transcription service is automated and not always super accurate. If transcription accuracy is critical for you, you might consider using a service with human translators like [Rev.com](//www.rev.com/).

.step(data-title='Updating Conversation State', data-file='routes/voice.js', data-highlight='22-27')
  :markdown
    ## Updating Conversation State

    ![Survey Flow Chart](//s3.amazonaws.com/howtodocs/flowchart5.png)

    Saving the user's response and maintaining the state of our conversation with the user is a concern best handled at the [model layer](//en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) of our server-side application, so we use our MongoDB-backed Mongoose model to handle this for us. 

    Abstracting the survey state from the controller also has the benefit of letting us re-use it for handling survey inputs from text messages. #winning!

    Let's dive into the model object next to briefly examine how that works.

.step(data-title='The Mongoose Schema', data-file='models/SurveyResponse.js', data-highlight='1-16')
  :markdown
    ## The Mongoose Schema

    ![Survey Flow Chart](//s3.amazonaws.com/howtodocs/flowchart5.png)

    In our model, we create a schema that allows us to constrain and validate the form of documents that we insert into MongoDB. However, the `Mixed` type lets us store arbitrary JavaScript objects in the `responses` array, so we have some flexibility there with the objects we use to store our user's answers.

    Mongooses are pretty sweet.

    ![Rikki Tikki Tavi](//s3.amazonaws.com/howtodocs/rikki.jpg)
    [<small>Don't even.</small>](//en.wikipedia.org/wiki/Rikki-Tikki-Tavi)

.step(data-title='Storing Responses', data-file='models/SurveyResponse.js', data-highlight='52-77')
  :markdown
    ## Storing Responses

    ![Survey Flow Chart](//s3.amazonaws.com/howtodocs/flowchart5.png)

    Prior to saving a response from the user, we convert the raw string values submitted into data types that will be easier for us to work with as we analyze and visualize our survey data.

.step(data-title='Queueing Up the Next Question', data-file='models/SurveyResponse.js', data-highlight='75-91')
  :markdown
    ## Queueing Up the Next Question

    ![Survey Flow Chart](//s3.amazonaws.com/howtodocs/flowchart6.png)

    After the current response is saved, we invoke the callback to our controller with the index of the next question in the survey. This may be longer than the actual length of the survey, which means we're finished asking questions!

    After you've finished asking questions, you might be interested in seeing how people responded to your survey. We won't spend too much time on visualizing the data, but we've included a bit of code in this sample app that shows you how you might approach that.
